\chapter{Results and Discussion}

\section{Results of the Experiments}

\subsection{First Set of Experiments: Determining the angle}
- Bei diesen Experimenten wurde noch kein RL Agent eingesetzt, sondern die erkennten Winkel direkt auf dem Bildschirm ausgegeben, um die Winkelbestimmung zu überprüfen.
- Problem bei Erkennung der farbigen Rechtecke auf Pendel und Stück Plastik,  dass von außen scheinendes Sonnenlicht die Farben veränderte, sodass die Farberkennung nicht mehr funktionierte. insbesondere bei dem Violett war dieser Effekt besonders stark ausgeprägt.
- Lösung durch anbringen von Symbolen, die verändern ihre Farbe nicht
- Trotz viel Kalibierung und Ausprobieren von verschiedenen Varianten der Formen (ausgedruckt vs. selbst gezeichnet) war keine zuverlässige Erkennung möglich, es wurden zu viele Elemente im Bild, wie z.B. Schrauben oder Objekte im Hintergrund (Personen, die durch das Bild gehen, Stühle, etc) erkannt, häufig als Kreis
- auch Filterung über OpenCVs moment() funktion liefert keine zuverlässige Erkennung
- Erkennung der Kreise über Hough Circle Transformation: Die Bestimmung der Dreiecke ist recht zuverlässig, aber die Bestimmung der Kreise, selbst mit dieser Methode ist stark fehleranfällig, oft werden Kreise nicht erkannt. Da diese Funktion aber in verschiedenen Quellen immer gute Ergebnisse liefert, vermute ich, dass das Bild der Kamera zu viel Rauschen enthält.
- verbesserter Ansatz zur Farberkennung liefert zuverlässige Winkel

\subsection{Second Set of Experiments: Optimizing Hardware}
- Pendel leichter machen hat nichts gebracht: Wenn das Pendel leichter ist, hat die Trägheit des Pendels aber nicht ausgereicht, um das Pendel nach oben zu bekommen

- bei hohen Strömen (1.51 A RMS, 2.14 A Peak und 2 A RMS, 2.83 A Peak) wird der Stepper Motor sehr heiß, weswegen ein Lüfter montiert wurde, der den Motor kühlt
- einer der zwei Stepper Motoren von stepperonline war nicht akkurat, die berechnete Position des Arduino hat nicht mit der tatsächlichen Position des Carts übereingestimmt
- geringe Ströme bei diesem Motor führen zu keiner Verbesserung des Motors bezüglich der Genauigkeit
- der andere Motor von stepperonline war akkurat, auch bei höhen Strömen
- Experimente mit verschiedenen Strömen lieferten einen RMS Strom von 1.2 A (Peak 1.69 A) als guten Tradeoff zwischen Kraft des Motors und Überhitzung des Motors für den Stepper Motor von stepperonline
- der Lüfter kann dann mit 3.3V betrieben werden und ist damit relativ leise

- Erkenntnisse aus Experimenten mit maximaler Geschwindigkeit: Je höher die Geschwindigkeit des Stepper Motors gewählt wird, desto geringer wird die Genauigkeit. Verschiedene Experimente lieferten eine maximale Geschwindigkeit von 60000 Steps/Sekunde, bei der der Motor noch akkurat war. Die maximale Beschleunigung wurde mit 1000000 Steps/Sekunde^2 ermittelt, bei der der Motor noch akkurat war. Bei höheren Werten ist der Stepper Motor nicht mehr in der Lage alle Schritte auszuführen, die ihm gesendet werden, sodass die Genauigkeit leidet.

\subsection{Third Set of Experiments: Optimizing Software}
- Durch Einsatz der FIFO-Queue nahm die Winkelgeschwindigkeit weniger extreme Werte an, siehe Abbildung \ref{fig:before_after_smoothing}. Die Werte vor der Glättung gehen betragsmäßig bis rund 700 rad/s, mit Ausreißern sogar bis 1400 rad/s. Nach der Glättung über die letzten 3 Winkel liegen die Werte bei maximal 400 rad/s.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.4\textwidth]{img/before_smoothing.png}
    \includegraphics[width=0.4\textwidth]{img/after_smoothing.png}
    \caption{Comparison of the angle speed with and without the FIFO-Queue of Length 3}
    \label{fig:before_after_smoothing}
\end{figure}
- Der Einstz des Flags, welches 1 ist, wenn der Pole oben ist, um zu unterscheiden, ob der Winkel und Winkelgeschwindigkeit Null sind weil der Pole oben ist, oder weil der RL Agent die Nachrichten der Kamera schneller abruft, als diese neue Winkel bestimmen kann, hat funktioniert. Ohne diese Fehlerkorrektur tauchte dieses Problem in einem Datensatz bei 85 von 10240 Beobachtungen auf (0.83\%)

- Beim Vergleich von unterschiedlichen Action Spaces fällt auf, die Größe es Action Space keinen Einfluss auf die Performance unter unterschiedlichen Reward Funktionen hat. In Abbildung \ref{fig:action_space_comparison} sieht man den Mean Reward pro Episode über ein Window von 100 Episoden für die Reward Funktionen $r_{highVelocity}$, $r_{simple}$ und $r_{complex}$ mit $\alpha=5$, $\beta=1$, $\gamma=1$ und $\delta=0$ und Größen des Action Spaces von 101 Aktionen, 51 Aktionen und 2 Aktionen. Nach etwa 200000 Steps konvergiert die Reward Funktion. Da einfachere Modelle komplexeren Modellen in der Regel vorzuziehen sind, wird für die weiteren Experimente ein diskreter action space mit 2 Aktionen verwendet.
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.3\textwidth]{img/high_velocity_reward.png}
    \includegraphics[width=0.3\textwidth]{img/simple_reward.png}
    \includegraphics[width=0.3\textwidth]{img/complex_reward.png}
    \caption{Comparison of the convergence of the mean reward per episode for different reward functions and action spaces}
    \label{fig:action_space_comparison}
\end{figure}
- Beim Beobachten des RL Agent wurde auch schnell klar, dass ohne den Einsatz von time.sleep(0.1) der Rl Agent nicht in der Lage ist, das Pendel nach oben zu bringen, weil er zu viele Aktionen macht, die das cart nur schnell kurze distanzen hin und her fahren lässt. somit lässt sich kein Moment des Pendels aufbauen, welches aber nötig ist, um nach oben zu schwingen. Mit erhöhter Trainingszeit ist dies aber denkbar, dass der RL Agent dies selbst lernt. Die vielen schnellen Aktionen sind dann in der Balancierungsphase nötig

- Simple Reward Funktion führt nicht zum gewünschten Verhalten, die beobachteten Winkel sind oft sehr groß ($\pm\pi$, was der unteren Position des Pendels entspricht), siehe Abbildung \ref{fig:angle_simple_reward}. Der weiße Bereich bei $\pm$ 1 Radiant kommt daher, dass die Kamera keine Seite des Pendels sehen kann, wenn es sich in der Horizontalen befindet. Daher können in diesem Zustand auch keine Winkel gemessen werden. Die beobachtete Winkelgeschwidigkeit ist oft sehr groß, was darauf hindeutet, dass das Pendel sehr schnell schwingt. Damit ist es zwar möglich, das Pendel nach oben zu bringen, aber sehr schwer das Pendel oben zu balancieren (siehe \ref{fig:angle_velocity_simple_reward}). Der mittlere Reward pro Episode konvergiert zu rund -1600 (siehe \ref{fig:mean_reward_simple_reward}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/simple_reward_angle.png}
    \caption{Seen angles of the pendulum over 200000 steps with the simple reward function}
    \label{fig:angle_simple_reward}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/simple_reward_angular_velocity.png}
    \caption{Seen angular velocities of the pendulum over 200000 steps with the simple reward function}
    \label{fig:angle_velocity_simple_reward}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/simple_reward_mean_reward.png}
    \caption{Mean reward per episode with the simple reward function}
    \label{fig:mean_reward_simple_reward}
\end{figure}

- Reward Funktion von Kimura & Kobayashi (1999) hat auch keine gute Performance, zwar stabilisiert sich auch hier der Mean Reward (siehe \ref{fig:mean_reward_kimura1999}), aber die Winkel erreichen gar nicht mehr die 0 Radiant, es findet also kein Aufschwung statt (siehe \ref{fig:angle_kimura1999}). Die beobachtete Winkelgeschwidigkeit nimmt stark ab über die Zeit (siehe \ref{fig:angle_velocity_kimura1999}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/kimura1999_angle.png}
    \caption{Seen angles of the pendulum over 200000 steps with the reward function of Kimura & Kobayashi (1999)}
    \label{fig:angle_kimura1999}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/kimura1999_angular_velocity.png}
    \caption{Seen angular velocities of the pendulum over 200000 steps with the reward function of Kimura & Kobayashi (1999)}
    \label{fig:angle_velocity_kimura1999}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/kimura_mean_reward.png}
    \caption{Mean reward per episode with the reward function of Kimura & Kobayashi (1999)}
    \label{fig:mean_reward_kimura1999}
\end{figure}

- Reward Funktion, die von Escobar et al (2020) vorgeschlagen wurde, hat nicht zum Erfolg geführt, die beobachteten Winkel konvergieren auch nicht zu 0 Radiant, siehe Abbildung \ref{fig:angle_escobar2020}. Die beobachteten Winkelgeschwidigkeiten (\ref{fig:angle_velocity_escobar2020}) sind vergleichbar mit den beobachteten Winkelgeschwidigkeiten der einfachen Reward Funktion, der erziehlte Reward ist numerisch höher, aber abnehmend (\ref{fig:mean_reward_escobar2020}).
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/escobar2020_angle.png}
    \caption{Seen angles of the pendulum over 200000 steps with the reward function of Escobar et al (2020)}
    \label{fig:angle_escobar2020}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/escobar2020_angular_velocity.png}
    \caption{Seen angular velocities of the pendulum over 200000 steps with the reward function of Escobar et al (2020)}
    \label{fig:angle_velocity_escobar2020}
\end{figure}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{img/escobar2020_mean_reward.png}
    \caption{Mean reward per episode with the reward function of Escobar et al (2020)}
    \label{fig:mean_reward_escobar2020}
\end{figure}

\section{Challenges and Limitations of Experiments}
- Da es sich nicht um eine Simulation, sondern um ein echtes System handelt, gibt es viele Herausforderungen, die in Simulationen nicht auftreten, wie z.B. die Erkennung der Winkel des Pendels in Echtzeit, verschiedene Delays, die durch die Hardware entstehen, und auch die akkurate Bestimmung der Winkelgeschwidigkeit: Winkeländerung geteilt durch sehr kleine Zeit ergibt einen großen Fehler, selbst bei kleinen Zeitabweichungen. Durch das Smoothing sollte der Effekt aber abgemildert werden.

- Um das Delay der Kamera zu bestimmen, wurde die aktuelle Zeit vor der Aufnahme des Bildes gespeichert und Vergleichen mit der Zeit, als die Berechnung des Winkel abgeschlossen war. Das Delay der Kamera und Bildverarbeitung schwankt um 0.1 Sekunden, das Delay aller Komponenten zusammen schwankt um 0.2 Sekunden, in Extremfällen beträgt es 0.7 Sekunden (siehe Abbildung \ref{fig:camera_delay_boxplot})
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{img/total_delay_camera_delay_boxplot.png}
    \caption{Boxplot of the Camera Delay and Image Processing (labeled as Camera Delay) and the Total Delay of all Components (labeled as Total Delay)}
    \label{fig:camera_delay_boxplot}
\end{figure}
- Mit zunehmender Zeit scheint das insgesamte Delay größer zu werden, die Ausreißer nehmen zu (siehe \ref{fig:total_delay_over_time}). Ich kann mir nicht erklären warum und auch die Beobachtung, dass bei vielen Experimenten das Skript für die Bildverarbeitung nach etwa 1.3 Millionen Steps zwar nicht abgestürzt ist, aber keine Daten mehr geliefert hat, ist nicht erklärbar.
\begin{figure}
    \centering
    \includegraphics[width=0.8\textwidth]{img/total_delay_over_time.png}
    \caption{Delay of the Camera and Image Processing for each Observation}
    \label{fig:total_delay_over_time}
\end{figure}
%TODO: eventuell messen des Delays über IPC?